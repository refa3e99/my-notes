# my-notes
## **Hello there!**
My name is **Abdulrahman** :smiley:, I'm a computer science student & im taking the *python* course.
---
[My LinkedIn](https://www.linkedin.com/in/abdulrahman-refae-9356b2216)
---
![Abdulrahman Mohammed](https://cambridgecarbonmap.org/wp-content/uploads/2021/09/coding.png
)
---
# **Learn the fundamentals of a good developer mindset in 15 minutes**
There are common issues faced by developers, also many small factors slowly and gradually harms a developer's projects.

They are not immediately destructive. Most of them only do long-term damage. Something you won’t see the damage for a year or more. So when somebody proposes them, often they sound harmless.

To avoid these issues, you should embrace the fundamental laws of software. You should develop a mindset that every developer should have. This mindset will help you make better decisions in your daily programming journey.

Here are the key points that every developer must master.

## 1. Conceiving The Purpose of Software
First of all, you should understand the purpose of the software. There is, in fact, a single purpose of all software: **To help people**.

## 2. The Goals of Software Design
When software is hard to create or modify, developers spend most of their time focusing on making things “just work,” and less time focusing on helping users. The design of software aims to make developers job as easy as possible so they can focus on what matters. You will create software that will help users and your software will continue to help them for a long time.

## 3. (Mis)understanding
Developers who don’t fully understand their work tend to develop complex systems. It can become a vicious cycle: misunderstanding leads to complexity, which leads to further misunderstanding, and so on.

## 4. Simplicity
- Programming is the act of reducing complexity to simplicity.
- A good developer creates things that are easy to understand so that it’s really easy to shake out all the bugs.
- The question is: *“How simple do you have to be?”*
Here is your answer: **Stupid, dumb simple.**

## 5. Complexity
- The source of many software failures is complexity. You start out with a simple project that can be completed in one month.Then you add complexity, and the task will take up to three months. Then you start to add features that fulfill some other purpose. Things get very complex because you expand your software purpose for no reason. The tasks will take six months.

**But that is not the end.**

- Then you take each piece of the feature and make it even more complex, and the task will take nine months. Then you start to introduce many new bugs because of the complexity in your code. Naturally, you start fixing them all without thinking how these fixes will affect other parts. At the end, when even small changes become hard. When bug fixes start to introduce new bugs, you will come to one of the most popular programming horror stories: Rewriting code from scratch.

## 6. Maintenance
Maintenance is one of the most important things in software development. Unfortunately, developers usually ignore how important it is. Quick coding and fast shipping look more important than code maintenance. This is the point where they make a mistake — ignorance of future code maintenance.
- **It is more important to reduce the effort of maintenance than it is to reduce the effort of implementation.**

## 7. Consistency
Consistency is a big part of simplicity. If you do something one way in one place, do it that way in every place. For example, if you name a variable thisIsVariable, then all of your variables should be named that way (otherVariable, anAnotherVariable, etc. not other_variable).

## 8. Prioritizing
When you prioritize your work, you should follow this rule: 
**The changes that will bring you a lot of value and require little effort are better than those that will bring little value and require a lot of effort.**

## 9. Solving Problems
- The first step is understanding. Know exactly what is being asked. Most hard problems are hard because you don’t understand them. Write down your problem and try to explain it to someone else.
- The second step is planning. Don’t take action. Sleep on it. Give your brain some time to analyze the problem and process the information but don’t spend too much time on planning.

**Think before acting.**

- The third step is dividing. Don’t try to solve one big problem. When you look at the problem as a whole, it can scare you. Divide it into smaller tasks and solve each sub-problem one by one. Once you solve each sub-problem, you connect the dots.

## 10. Good enough is fine
**Start small, improve it, then extend.**

The incremental design should be your guide. Here is how you would use it to design a calculator:

1. Plan a system that does only addition and nothing else.
2. Implement it.
3. Improve the now-existing system’s design so you can add other operations also.
4. Plan subtraction and repeat step 2 and 3.
5. Plan multiplication and repeat step 2 and 3.
6. Plan division and repeat step 2 and 3.

## 11. Predictions
You can’t predict the future, so no matter how generic your solution is, it will not be generic enough to satisfy the actual future requirements you will have. Most probably, this time will never come and the code you wrote to solve future problems will increase complexity, make it hard to change the pieces of code and eventually it will become a burden that may destroy your software.

Don’t predict to future. Be only as generic as you know you need to be right now.

## 12. Assumptions
One of the great killers of a software project is assumptions. Let’s see how an assumption can kill a software project.

A developer knows that they have to develop a system to do X. Then they think that the system will require them to do Y in the future, and they implement Y as well. They write thousands of lines of code to design Y.

In the future, the developer realizes that the current requirements are completely different than what they thought. But now, the software has unnecessary codes that make it hard to throw away because everything is intertwined. It takes months to refactor the code and now they think to rewrite the whole software from scratch which will cause them to lose months.

## 13. Stop Reinventing
The only times it’s okay to reinvent the wheel is when any of the following are true:

- You need something that doesn’t exist yet
- All of the existing “wheels” are bad technologies or incapable of handling your needs
- The existing “wheels” aren’t being properly maintained

Simple rule:

**Don’t reinvent the wheel.**

## 14. Resistance
As a developer, your first reaction to changing requests should be **“NO’’**.

Always resist adding more code, more features until you are convinced that they are required and there is a need to implement them. Because unnecessary changes will increase defects in your software.

## 15. Automation
Don’t spend your time on repetitive tasks. Set them up and forget about them. They can work while you are sleeping. When you realize that you are doing something again and again, just remember this rule:

**If you can automate it, automate it.**

## 16. Code measurement
The optimum code is a small bunch of code that is easy to understand, easy to read.

## 17. Productivity
How do you measure your productivity?

By writing more lines of code or by throwing hundreds of lines of code away?!

Your main goal should be keeping your code base as small as possible. The question is not “How can I write more code?” rather it should be “How can I remove more code?”

*“One of my most productive days was throwing away 1000 lines of code.” — Ken Thompson*

## 18. Testing
When should you add logging and error handling to your project?

You should add logging in a very early stage. This will help you to find the problem easily and save your time.
**Untested code is the code that doesn’t work**

## 19. (Under)Estimation
Usually, they underestimate things rather than overestimate them. They underestimate the time and effort required to develop a small amount of code or a feature. In the end, this underestimation leads to missing deadlines.

The solution: Break the big thing into smaller things. The smaller it is, the easier it is to estimate. You’re probably still going to get it wrong, but you’ll be a lot less wrong than if you estimated a big project.

**Everything takes longer than you think.**

## 20. Running Away From Rewriting
**Rewriting code is often a developer delusion, not the solution in most cases.**

## 21. Documentation and Commenting
One of the common misconceptions about commenting is that developers add comments that say what code is doing. This is wrong. That should be obvious from reading the code. If it’s not obvious, it means that it is not readable and it should be made simpler.

**Write a comment to explain “WHY”, not to explain “WHAT”.**

## 22. Picking Technologies (Tools, Libraries, etc.)
**Don’t depend on external technologies. But when you have to do so, try to reduce your dependency on them as much as you can.**

There are a few factors you should consider before you start using some technology:

- Is there active development behind it?
- Will it continue to be maintained?
- How easy is it to switch away from?
- What does the community say about it?

**If you can find the right answer these questions, you can reduce the risk of picking the wrong technology.**

## 23. Self-Development
Keep learning. Try out different programming languages and tools, read books on software development. They will give you another perspective. Every day small improvements will make a real difference in your knowledge and skills.

## 24. Don’t be a hero
A lot of times it’s better to be a quitter than a hero.

**Don’t be obsessive. Know when to quit. Don’t hesitate to ask for help.**

You can read more of articles at [Click here](https://huseyinpolatyuruk.com)